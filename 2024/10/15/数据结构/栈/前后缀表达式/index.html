<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><title>前后缀表达式 - Orion Blog</title><link rel="stylesheet" href="/css/grid.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/ringo.css"><link rel="icon" type="image/x-icon" href="/img/favicon.ico"><meta name=" " content=""><meta name=" " content=""><meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:yellow;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style></head><body><header id="header" class="clearfix" onclick='window.open("/","_self")'><div class="site-name"><a href="/" id="logo" class="site-title">Orion Blog</a><p class="description site-description"><span style="padding-top:20px;font-size:10px"></span></p></div></header><div id="sidebar" role="complementary"><section class="widget"><ul class="menu widget-list"><li class="menu-item"><a href="/" class="menu-item-link">Home</a></li><li class="menu-item"><a href="/archives" class="menu-item-link">Archives</a></li><li class="menu-item"><a href="/categories" class="menu-item-link">Categories</a></li><li class="menu-item"><a href="/tags" class="menu-item-link">Tags</a></li></ul></section><section class="widget sidebar-foot"><ul class="widget-list"><li>Theme <a rel="nofollow" target="_blank" href="https://github.com/HeliumOI/hexo-theme-ringo">Ringo</a> by <a target="_blank" href="/">Orion</a></li><li>Proudly powered by <a rel="nofollow" target="_blank" href="https://hexo.io/">Hexo</a></li></ul></section></div><div id="helpbar"><div class="back-to-top"><button id="back2top">↑</button><script>back2top.onclick=function(){var o=document.body.scrollTop||document.documentElement.scrollTop;scrollBy(0,-o)}</script></div></div><main class="main"><div id="body"><div class="container"><div class="col-12" id="main" role="main"><article class="post post-atpost" itemscope itemtype="http://schema.org/BlogPosting"><div class="post-title"><h1 class="post-title post-title-atpage" itemprop="name headline"><a itemprop="url" href="/2024/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E5%89%8D%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/">前后缀表达式</a></h1></div><ul class="post-meta post-meta-atpage"><li class="post-time">2024-10-15</li><li><div class="article-category"><a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>►<a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/">栈</a></div></li></ul><div class="post-content" itemprop="articleBody"><h1><span id="gai-nian-ding-yi">概念定义</span><a href="#gai-nian-ding-yi" class="header-anchor"></a></h1><ol type="1"><li><p>中缀表达式：操作符在操作数中间，就是平时我们计算识别的算术表达式，例如 3+4-5。</p><p>计算方法：略。</p></li><li><p>前缀表达式（波兰表达式）：操作符在操作数的前面，比如 +-543。</p><p>计算方法：遇到操作符挨着两个数字逆序计算然后求解消去，比如-54=4-5计算后得到+（-1）3=3-1=2。</p></li><li><p>后缀表达式（逆波兰表达式）：操作符在操作数的后面，比如 34+5-。</p><p>计算方法：遇到操作符后挨着两个数字顺序计算然后求解消去，比如34+=3+4计算后得到75-=7-5=2。</p></li></ol><span id="more"></span><h1><span id="suan-fa-si-xiang">算法思想</span><a href="#suan-fa-si-xiang" class="header-anchor"></a></h1><p><strong>中缀表达式转前缀表达式：</strong></p><ol type="1"><li>我们需要初始两个栈：OPTR栈-寄存运算符（过渡栈），OPND栈-寄存操作数或运算符（最终栈）。</li><li>然后从右往左依次读入表达式字符，遵守以下规则：<ol type="1"><li>如果读入的是操作数，压入OPND栈。</li><li>如果读入的是运算符：<ol type="1"><li>如果是右括号')'，直接压入OPTR栈顶，因为这是优先级最高的。</li><li>如果是左括号'('，依次弹出OPTR栈中的运算符并压入OPND栈，直到OPTR栈顶元素为左括号'('，弹出结束。</li><li>如果是运算符，和当前OPTR栈顶元素做优先级比较：如果当前运算符优先级大于栈顶元素，直接压入OPTR栈顶；如果当前运算符优先级小于等于栈顶元素，将栈中大于当前运算符的元素依次压入OPND栈中直到遇到平级或低级。</li></ol></li></ol></li><li>重复以上步骤，直到表达式结束，OPND从栈顶到栈底的顺序为前缀表达式，OPTR栈顶为空。</li></ol><p><strong>中缀表达式转后缀表达式：</strong></p><ol type="1"><li>我们需要初始两个栈：OPTR栈-寄存运算符（过渡栈），OPND栈-寄存操作数或运算符（最终栈）。</li><li>然后从左往右依次读入表达式字符，遵守以下规则：<ol type="1"><li>如果读入的是操作数，压入OPND栈。</li><li>如果读入的是运算符：<ol type="1"><li>如果是左括号'('，直接压入OPTR栈顶，因为这是优先级最高的。</li><li>如果是右括号')'，依次弹出OPTR栈中的运算符并压入OPND栈，直到OPTR栈顶元素为左括号'('，弹出结束。</li><li>如果是运算符，和当前OPTR栈顶元素做优先级比较：如果当前运算符优先级大于栈顶元素，直接压入OPTR栈顶；如果当前运算符优先级小于等于栈顶元素，将栈中大于当前运算符的元素依次压入OPND栈中直到遇到平级或低级。</li></ol></li></ol></li><li>重复以上步骤，直到表达式结束，OPND从栈底到栈顶的顺序为后缀表达式，OPTR栈顶为空。</li></ol><p>其实思想和中缀表达式求解一样，不过我们现在不能直接运算了，而是需要把字符保留罢了。</p><h1><span id="dai-ma-shi-xian">代码实现</span><a href="#dai-ma-shi-xian" class="header-anchor"></a></h1><p>代码写的很差，仅作记录不喜勿喷，但欢迎指点。</p><h3><span id="zhong-zhui-biao-da-shi-zhuan-qian-zhui-biao-da-shi">中缀表达式转前缀表达式</span><a href="#zhong-zhui-biao-da-shi-zhuan-qian-zhui-biao-da-shi" class="header-anchor"></a></h3><pre class="c"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;

#define MAX_STACK_SIZE 100

// 判断运算符优先级
int precedence(char op) {
    switch (op) {
    case '+':
    case '-':
        return 1;
    case '*':
    case '/':
        return 2;
    default:
        return 0;
    }
}

// 执行运算
int applyOperator(char op, int a, int b) {
    switch (op) {
    case '+': return a + b;
    case '-': return a - b;
    case '*': return a * b;
    case '/':
        if (b == 0) {
            printf("错误: 除以零\n");
            exit(EXIT_FAILURE);
        }
        return a / b;
    default:
        printf("错误: 无效的运算符 '%c'\n", op);
        exit(EXIT_FAILURE);
    }
}

// 打印栈的内容, opndStack 为 char** 类型
void printStacks(char* optrStack, int optrTop, char** opndStack, int opndTop) {
    printf("OPTR栈: ");
    if (optrTop == -1) {
        printf("空");
    }
    else {
        for (int i = 0; i &lt;= optrTop; i++) {
            printf("%c ", optrStack[i]);
        }
    }

    printf("\nOPND栈: ");
    if (opndTop == -1) {
        printf("空");
    }
    else {
        for (int i = 0; i &lt;= opndTop; i++) {
            printf("%s ", opndStack[i]);
        }
    }
    printf("\n\n");
}

// 将运算符转换为字符串的函数
char* operatorToString(char op) {
    char* resultStr = (char*)malloc(2 * sizeof(char));
    if (!resultStr) {
        printf("内存分配失败\n");
        exit(EXIT_FAILURE);
    }
    resultStr[0] = op;
    resultStr[1] = '\0';
    return resultStr;
}

// 中缀表达式转前缀表达式
char** infixToPrefix(const char* infix) {
    // 初始化两个栈，这里的opnd栈存放字符串，而optr栈是运算符栈
    char* optrStack = (char*)malloc(MAX_STACK_SIZE * sizeof(char));
    char** opndStack = (char**)malloc(MAX_STACK_SIZE * sizeof(char*));

    if (!optrStack || !opndStack) {
        printf("内存分配失败\n");
        exit(EXIT_FAILURE);
    }

    // 初始化两个栈的指针
    int optrTop = -1;
    int opndTop = -1;

    int i = strlen(infix) - 1;
    char token;

    printf("中缀表达式: %s\n\n", infix);

    // 遍历表达式
    while (i &gt;= 0) {
        token = infix[i];
        printf("读取字符：%c\n", token);

        // 跳过空格
        if (isspace(token)) {
            i--;
            continue;
        }

        // 如果是数字，处理多位数字
        if (isdigit(token)) {
            char* s = (char*)malloc(MAX_STACK_SIZE * sizeof(char));
            if (!s) {
                printf("内存分配失败\n");
                exit(EXIT_FAILURE);
            }
            int p = 0;
            while (i &gt;= 0 &amp;&amp; isdigit(infix[i])) {
                s[p++] = infix[i--];
            }
            s[p] = '\0';
            // 反转字符串
            for (int k = 0; k &lt; p / 2; k++) {
                char temp = s[k];
                s[k] = s[p - 1 - k];
                s[p - 1 - k] = temp;
            }
            opndStack[++opndTop] = s;
            printf("将操作数 %s 压入 OPND 栈\n", s);
            printStacks(optrStack, optrTop, opndStack, opndTop);
            continue;
        }

        // 如果是右括号，直接压入 OPTR 栈
        if (token == ')') {
            if (optrTop &gt;= MAX_STACK_SIZE - 1) {
                printf("错误: 运算符栈溢出\n");
                free(optrStack);
                for (int j = 0; j &lt;= opndTop; j++) {
                    free(opndStack[j]);
                }
                free(opndStack);
                exit(EXIT_FAILURE);
            }
            optrStack[++optrTop] = token;
            printf("将 ')' 压入 OPTR 栈\n");
            printStacks(optrStack, optrTop, opndStack, opndTop);
            i--;
            continue;
        }

        // 如果是左括号，处理括号内的所有运算
        if (token == '(') {
            printf("遇到 '('，处理括号内的所有运算\n");
            while (optrTop &gt;= 0 &amp;&amp; optrStack[optrTop] != ')') {
                if (optrTop &lt; 0 || opndTop &lt; 1) {
                    printf("错误: 表达式不合法\n");
                    free(optrStack);
                    for (int j = 0; j &lt;= opndTop; j++) {
                        free(opndStack[j]);
                    }
                    free(opndStack);
                    exit(EXIT_FAILURE);
                }
                char op = optrStack[optrTop--];
                char* resultStr = operatorToString(op);
                opndStack[++opndTop] = resultStr;
                printStacks(optrStack, optrTop, opndStack, opndTop);
            }
            if (optrTop &gt;= 0) {
                optrTop--; // 弹出右括号
            }
            i--;
            continue;
        }

        // 如果是运算符，处理优先级
        while (optrTop &gt;= 0 &amp;&amp; precedence(optrStack[optrTop]) &gt;= precedence(token)) {
            if (optrTop &lt; 0 || opndTop &lt; 1) {
                printf("错误: 表达式不合法\n");
                free(optrStack);
                for (int j = 0; j &lt;= opndTop; j++) {
                    free(opndStack[j]);
                }
                free(opndStack);
                exit(EXIT_FAILURE);
            }
            char op = optrStack[optrTop--];
            char* resultStr = operatorToString(op);
            opndStack[++opndTop] = resultStr;
            printStacks(optrStack, optrTop, opndStack, opndTop);
        }

        // 优先级大于栈顶直接入栈
        if (optrTop &gt;= MAX_STACK_SIZE - 1) {
            printf("错误: 运算符栈溢出\n");
            free(optrStack);
            for (int j = 0; j &lt;= opndTop; j++) {
                free(opndStack[j]);
            }
            free(opndStack);
            exit(EXIT_FAILURE);
        }
        optrStack[++optrTop] = token;
        printf("将运算符 '%c' 压入 OPTR 栈\n", token);
        printStacks(optrStack, optrTop, opndStack, opndTop);

        i--;
    }

    // 处理剩余的运算符
    while (optrTop &gt;= 0) {
        if (optrTop &lt; 0 || opndTop &lt; 1) {
            printf("错误: 表达式不合法\n");
            free(optrStack);
            for (int j = 0; j &lt;= opndTop; j++) {
                free(opndStack[j]);
            }
            free(opndStack);
            exit(EXIT_FAILURE);
        }
        char op = optrStack[optrTop--];
        char* resultStr = operatorToString(op);
        opndStack[++opndTop] = resultStr;
        printStacks(optrStack, optrTop, opndStack, opndTop);
    }

    if (optrTop != -1) {
        printf("错误: 表达式不合法\n");
        free(optrStack);
        for (int j = 0; j &lt;= opndTop; j++) {
            free(opndStack[j]);
        }
        free(opndStack);
        exit(EXIT_FAILURE);
    }

    char** prefix = (char**)malloc((MAX_STACK_SIZE + 1) * sizeof(char*));
    if (!prefix) {
        printf("内存分配失败\n");
        exit(EXIT_FAILURE);
    }
    for (int j = 0; j &lt;= opndTop; j++) {
        prefix[j] = (char*)malloc(strlen(opndStack[opndTop - j]) + 1);
        if (!prefix[j]) {
            printf("内存分配失败\n");
            exit(EXIT_FAILURE);
        }
        strcpy(prefix[j], opndStack[opndTop - j]);
        free(opndStack[opndTop - j]);
    }
    prefix[opndTop + 1] = NULL;

    free(optrStack);
    free(opndStack);

    return prefix;
}

// 前缀表达式求值
int prefixExpressionCompute(char** prefix) {
    // 保存中间数字的栈
    int* stack = (int*)malloc(MAX_STACK_SIZE * sizeof(int));
    // 栈顶指针
    int top = -1;

    // 计算前缀表达式的长度
    int length = 0;
    while (prefix[length] != NULL) {
        length++;
    }

    // 从后向前遍历前缀表达式
    for (int i = length - 1; i &gt;= 0; i--) {
        if (isdigit(prefix[i][0])) {
            stack[++top] = atoi(prefix[i]);
        }
        else {
            int a = stack[top--];
            int b = stack[top--];
            int result = applyOperator(prefix[i][0], a, b);
            stack[++top] = result;
        }
    }

    if (top != 0) {
        printf("错误: 表达式不合法\n");
        free(stack);
        exit(EXIT_FAILURE);
    }
    int result = stack[top];
    free(stack);
    return result;
}

int main() {
    const char* expression = "5+2*5+(60/3+7*3)+2";
    char** prefix = infixToPrefix(expression);
    printf("前缀表达式: ");
    for (int i = 0; prefix[i] != NULL; i++) {
        printf("%s ", prefix[i]);
    }
    printf("\n");
    printf("前缀表达式求值: %d\n", prefixExpressionCompute(prefix));
    for (int i = 0; prefix[i] != NULL; i++) {
        free(prefix[i]);
    }
    free(prefix);
    return 0;
}</code></pre><p>输出结果</p><pre><code>中缀表达式: 5+2*5+(60/3+7*3)+2

读取字符：2
将操作数 2 压入 OPND 栈
OPTR栈: 空
OPND栈: 2

读取字符：+
将运算符 '+' 压入 OPTR 栈
OPTR栈: +
OPND栈: 2

读取字符：)
将 ')' 压入 OPTR 栈
OPTR栈: + )
OPND栈: 2

读取字符：3
将操作数 3 压入 OPND 栈
OPTR栈: + )
OPND栈: 2 3

读取字符：*
将运算符 '*' 压入 OPTR 栈
OPTR栈: + ) *
OPND栈: 2 3

读取字符：7
将操作数 7 压入 OPND 栈
OPTR栈: + ) *
OPND栈: 2 3 7

读取字符：+
OPTR栈: + )
OPND栈: 2 3 7 *

将运算符 '+' 压入 OPTR 栈
OPTR栈: + ) +
OPND栈: 2 3 7 *

读取字符：3
将操作数 3 压入 OPND 栈
OPTR栈: + ) +
OPND栈: 2 3 7 * 3

读取字符：/
将运算符 '/' 压入 OPTR 栈
OPTR栈: + ) + /
OPND栈: 2 3 7 * 3

读取字符：0
将操作数 60 压入 OPND 栈
OPTR栈: + ) + /
OPND栈: 2 3 7 * 3 60

读取字符：(
遇到 '('，处理括号内的所有运算
OPTR栈: + ) +
OPND栈: 2 3 7 * 3 60 /

OPTR栈: + )
OPND栈: 2 3 7 * 3 60 / +

读取字符：+
OPTR栈: 空
OPND栈: 2 3 7 * 3 60 / + +

将运算符 '+' 压入 OPTR 栈
OPTR栈: +
OPND栈: 2 3 7 * 3 60 / + +

读取字符：5
将操作数 5 压入 OPND 栈
OPTR栈: +
OPND栈: 2 3 7 * 3 60 / + + 5

读取字符：*
将运算符 '*' 压入 OPTR 栈
OPTR栈: + *
OPND栈: 2 3 7 * 3 60 / + + 5

读取字符：2
将操作数 2 压入 OPND 栈
OPTR栈: + *
OPND栈: 2 3 7 * 3 60 / + + 5 2

读取字符：+
OPTR栈: +
OPND栈: 2 3 7 * 3 60 / + + 5 2 *

OPTR栈: 空
OPND栈: 2 3 7 * 3 60 / + + 5 2 * +

将运算符 '+' 压入 OPTR 栈
OPND栈: 2 3 7 * 3 60 / + + 5 2 * +

读取字符：5
将操作数 5 压入 OPND 栈
OPTR栈: +
OPND栈: 2 3 7 * 3 60 / + + 5 2 * + 5

OPTR栈: 空
OPND栈: 2 3 7 * 3 60 / + + 5 2 * + 5 +

前缀表达式: + 5 + * 2 5 + + / 60 3 * 7 3 2
前缀表达式求值: 58</code></pre><h3><span id="zhong-zhui-biao-da-shi-zhuan-hou-zhui-biao-da-shi">中缀表达式转后缀表达式</span><a href="#zhong-zhui-biao-da-shi-zhuan-hou-zhui-biao-da-shi" class="header-anchor"></a></h3><pre class="c"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;

#define MAX_STACK_SIZE 100

// 判断运算符优先级
int precedence(char op) {
    switch (op) {
    case '+':
    case '-':
        return 1;
    case '*':
    case '/':
        return 2;
    default:
        return 0;
    }
}

// 执行运算
int applyOperator(char op, int a, int b) {
    switch (op) {
    case '+': return a + b;
    case '-': return a - b;
    case '*': return a * b;
    case '/':
        if (b == 0) {
            printf("错误: 除以零\n");
            exit(EXIT_FAILURE);
        }
        return a / b;
    default:
        printf("错误: 无效的运算符 '%c'\n", op);
        exit(EXIT_FAILURE);
    }
}

// 打印栈的内容, opndStack 为 char** 类型
void printStacks(char* optrStack, int optrTop, char** opndStack, int opndTop) {
    printf("OPTR栈: ");
    if (optrTop == -1) {
        printf("空");
    }
    else {
        for (int i = 0; i &lt;= optrTop; i++) {
            printf("%c ", optrStack[i]);
        }
    }

    printf("\nOPND栈: ");
    if (opndTop == -1) {
        printf("空");
    }
    else {
        for (int i = 0; i &lt;= opndTop; i++) {
            printf("%s ", opndStack[i]);
        }
    }
    printf("\n\n");
}

// 将运算符转换为字符串的函数
char* operatorToString(char op) {
    char* resultStr = (char*)malloc(2 * sizeof(char));
    if (!resultStr) {
        printf("内存分配失败\n");
        exit(EXIT_FAILURE);
    }
    resultStr[0] = op;
    resultStr[1] = '\0';
    return resultStr;
}

// 中缀表达式转后缀表达式
char** infixToPostfix(const char* infix) {
    // 初始化两个栈，这里的opnd栈存放字符串，而optr栈是运算符栈
    char* optrStack = (char*)malloc(MAX_STACK_SIZE * sizeof(char));
    char** opndStack = (char**)malloc(MAX_STACK_SIZE * sizeof(char*));

    if (!optrStack || !opndStack) {
        printf("内存分配失败\n");
        exit(EXIT_FAILURE);
    }

    // 初始化两个栈的指针
    int optrTop = -1;
    int opndTop = -1;

    int i = 0;
    char token;

    printf("中缀表达式: %s\n\n", infix);

    // 遍历表达式
    while ((token = infix[i]) != '\0') {
        printf("读取字符：%c\n", token);

        // 跳过空格
        if (isspace(token)) {
            i++;
            continue;
        }

        // 如果是数字，处理多位数字
        if (isdigit(token)) {
            char* s = (char*)malloc(MAX_STACK_SIZE * sizeof(char));
            if (!s) {
                printf("内存分配失败\n");
                exit(EXIT_FAILURE);
            }
            int p = 0; // 字符串指针
            while (isdigit(infix[i])) {
                s[p++] = infix[i++];
            }
            s[p] = '\0'; // 在字符串末尾添加\0
            opndStack[++opndTop] = s;
            printf("将操作数 %s 压入 OPND 栈\n", s);
            printStacks(optrStack, optrTop, opndStack, opndTop);
            continue;
        }

        // 如果是左括号，直接压入 OPTR 栈
        if (token == '(') {
            if (optrTop &gt;= MAX_STACK_SIZE - 1) {
                printf("错误: 运算符栈溢出\n");
                free(optrStack);
                for (int j = 0; j &lt;= opndTop; j++) {
                    free(opndStack[j]);
                }
                free(opndStack);
                exit(EXIT_FAILURE);
            }
            optrStack[++optrTop] = token;
            printf("将 '(' 压入 OPTR 栈\n");
            printStacks(optrStack, optrTop, opndStack, opndTop);
            i++;
            continue;
        }

        // 如果是右括号，处理括号内的所有运算
        if (token == ')') {
            printf("遇到 ')'，处理括号内的所有运算\n");
            while (optrTop &gt;= 0 &amp;&amp; optrStack[optrTop] != '(') {
                if (optrTop &lt; 0 || opndTop &lt; 1) {
                    printf("错误: 表达式不合法\n");
                    free(optrStack);
                    for (int j = 0; j &lt;= opndTop; j++) {
                        free(opndStack[j]);
                    }
                    free(opndStack);
                    exit(EXIT_FAILURE);
                }
                char op = optrStack[optrTop--];
                char* resultStr = operatorToString(op);
                opndStack[++opndTop] = resultStr;
                printStacks(optrStack, optrTop, opndStack, opndTop);
            }
            if (optrTop &gt;= 0) {
                optrTop--; // 弹出左括号
            }
            i++;
            continue;
        }

        // 如果是运算符，处理优先级
        while (optrTop &gt;= 0 &amp;&amp; precedence(optrStack[optrTop]) &gt;= precedence(token)) {
            if (optrTop &lt; 0 || opndTop &lt; 1) {
                printf("错误: 表达式不合法\n");
                free(optrStack);
                for (int j = 0; j &lt;= opndTop; j++) {
                    free(opndStack[j]);
                }
                free(opndStack);
                exit(EXIT_FAILURE);
            }
            char op = optrStack[optrTop--];
            char* resultStr = operatorToString(op);
            opndStack[++opndTop] = resultStr;
            printStacks(optrStack, optrTop, opndStack, opndTop);
        }

        // 优先级大于栈顶直接入栈
        if (optrTop &gt;= MAX_STACK_SIZE - 1) {
            printf("错误: 运算符栈溢出\n");
            free(optrStack);
            for (int j = 0; j &lt;= opndTop; j++) {
                free(opndStack[j]);
            }
            free(opndStack);
            exit(EXIT_FAILURE);
        }
        optrStack[++optrTop] = token;
        printf("将运算符 '%c' 压入 OPTR 栈\n", token);
        printStacks(optrStack, optrTop, opndStack, opndTop);

        i++;
    }

    // 处理剩余的运算符
    while (optrTop &gt;= 0) {
        if (optrTop &lt; 0 || opndTop &lt; 1) {
            printf("错误: 表达式不合法\n");
            free(optrStack);
            for (int j = 0; j &lt;= opndTop; j++) {
                free(opndStack[j]);
            }
            free(opndStack);
            exit(EXIT_FAILURE);
        }
        char op = optrStack[optrTop--];
        char* resultStr = operatorToString(op);
        opndStack[++opndTop] = resultStr;
        printStacks(optrStack, optrTop, opndStack, opndTop);
    }

    if (optrTop != -1) {
        printf("错误: 表达式不合法\n");
        free(optrStack);
        for (int j = 0; j &lt;= opndTop; j++) {
            free(opndStack[j]);
        }
        free(opndStack);
        exit(EXIT_FAILURE);
    }

    char** postfix = (char**)malloc((MAX_STACK_SIZE + 1) * sizeof(char*));
    if (!postfix) {
        printf("内存分配失败\n");
        exit(EXIT_FAILURE);
    }
    for (int j = 0; j &lt;= opndTop; j++) {
        postfix[j] = (char*)malloc(strlen(opndStack[j]) + 1);
        if (!postfix[j]) {
            printf("内存分配失败\n");
            exit(EXIT_FAILURE);
        }
        strcpy(postfix[j], opndStack[j]);
        free(opndStack[j]);
    }
    postfix[opndTop + 1] = NULL;

    free(optrStack);
    free(opndStack);

    return postfix;
}

// 后缀表达式求值
int postfixExpressionCompute(char** postfix) {
    // 保存中间数字的栈
    int* stack = (int*)malloc(MAX_STACK_SIZE * sizeof(int));
    // 栈顶指针
    int top = -1;

    for (int i = 0; postfix[i] != NULL; i++) {
        if (isdigit(postfix[i][0])) {
            stack[++top] = atoi(postfix[i]);
        }
        else {
            int b = stack[top--];
            int a = stack[top--];
            int result = applyOperator(postfix[i][0], a, b);
            stack[++top] = result;
        }
    }

    if (top != 0) {
        printf("错误: 表达式不合法\n");
        free(stack);
        exit(EXIT_FAILURE);
    }
    int result = stack[top];
    free(stack);
    return result;
}

int main() {
    const char* expression = "5+2*5+(60/3+7*3)+2";
    char** postfix = infixToPostfix(expression);
    printf("后缀表达式: ");
    for (int i = 0; postfix[i] != NULL; i++) {
        printf("%s ", postfix[i]);
    }
    printf("\n");
    printf("后缀表达式求值: %d\n", postfixExpressionCompute(postfix));
    for (int i = 0; postfix[i] != NULL; i++) {
        free(postfix[i]);
    }
    free(postfix);
    return 0;
}</code></pre><p>输出结果</p><pre><code>中缀表达式: 5+2*5+(60/3+7*3)+2

读取字符：5
将操作数 5 压入 OPND 栈
OPTR栈: 空
OPND栈: 5 

读取字符：+
将运算符 '+' 压入 OPTR 栈
OPTR栈: + 
OPND栈: 5 

读取字符：2
将操作数 2 压入 OPND 栈
OPTR栈: + 
OPND栈: 5 2 

读取字符：*
将运算符 '*' 压入 OPTR 栈
OPTR栈: + *
OPND栈: 5 2

读取字符：5
将操作数 5 压入 OPND 栈
OPTR栈: + *
OPND栈: 5 2 5

读取字符：+
OPTR栈: +
OPND栈: 5 2 5 *

OPTR栈: 空
OPND栈: 5 2 5 * +

将运算符 '+' 压入 OPTR 栈
OPTR栈: +
OPND栈: 5 2 5 * +

读取字符：(
将 '(' 压入 OPTR 栈
OPTR栈: + (
OPND栈: 5 2 5 * +

读取字符：6
将操作数 60 压入 OPND 栈
OPTR栈: + (
OPND栈: 5 2 5 * + 60

读取字符：/
将运算符 '/' 压入 OPTR 栈
OPTR栈: + ( /
OPND栈: 5 2 5 * + 60

读取字符：3
将操作数 3 压入 OPND 栈
OPTR栈: + ( /
OPND栈: 5 2 5 * + 60 3

读取字符：+
OPTR栈: + (
OPND栈: 5 2 5 * + 60 3 /

将运算符 '+' 压入 OPTR 栈
OPTR栈: + ( +
OPND栈: 5 2 5 * + 60 3 /

读取字符：7
将操作数 7 压入 OPND 栈
OPTR栈: + ( +
OPND栈: 5 2 5 * + 60 3 / 7

读取字符：*
将运算符 '*' 压入 OPTR 栈
OPTR栈: + ( + *
OPND栈: 5 2 5 * + 60 3 / 7

读取字符：3
将操作数 3 压入 OPND 栈
OPTR栈: + ( + *
OPND栈: 5 2 5 * + 60 3 / 7 3

读取字符：)
遇到 ')'，处理括号内的所有运算
OPTR栈: + ( +
OPND栈: 5 2 5 * + 60 3 / 7 3 *

OPTR栈: + (
OPND栈: 5 2 5 * + 60 3 / 7 3 * +

读取字符：+
OPTR栈: 空
OPND栈: 5 2 5 * + 60 3 / 7 3 * + +

将运算符 '+' 压入 OPTR 栈
OPTR栈: +
OPND栈: 5 2 5 * + 60 3 / 7 3 * + +

读取字符：2
将操作数 2 压入 OPND 栈
OPTR栈: +
OPND栈: 5 2 5 * + 60 3 / 7 3 * + + 2

OPTR栈: 空
OPND栈: 5 2 5 * + 60 3 / 7 3 * + + 2 +

后缀表达式: 5 2 5 * + 60 3 / 7 3 * + + 2 +
后缀表达式求值: 58</code></pre><blockquote><p>文章作者： <a href="/">Orion</a></p><p>文章链接： <a href="https://www.orionverse.blog/2024/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E5%89%8D%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/">https://www.orionverse.blog/2024/10/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E5%89%8D%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</a></p><p>版权声明：除另有声明外，本博客文章均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明原作者与文章出处。</p></blockquote></div><p itemprop="keywords" class="tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a> <a href="/tags/%E6%A0%88/">栈</a></p></article><div class="post-near"><div class="post-near-child post-near-child-left"><a href="/2024/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88/%E6%A0%88-%E5%9B%9E%E6%BA%AF%E6%B3%95/">栈-回溯法 &laquo;</a><br>上一篇 &laquo;</div><div class="post-near-child post-near-child-right"><a href="/2024/10/16/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/Dynamics/Dynamics-Ch07-08-4/">&raquo; Dynamics (Ch07-08)-4</a><br>&raquo; 下一篇</div></div></div><div id="comments"></div><footer id="footer" role="contentinfo">&copy; 2024 - 2024<br><br><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_value_site_pv">......</span> visits · <span id="busuanzi_value_site_uv">......</span> visitors</footer></div></div></main><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/styles/default.min.css"><script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.1.0/build/highlight.min.js"></script><script>hljs.initHighlightingOnLoad()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });</script><script src=""></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script><script src="/js/wrap.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/viewerjs@1.10.0/dist/viewer.min.css"><script src="https://cdn.jsdelivr.net/npm/viewerjs@1.10.0/dist/viewer.min.js"></script><script>Viewer.setDefaults({zoomRatio:[.5],show:function(){this.viewer.zoomTo(1)}});var imageList=document.querySelector(".post-content").getElementsByTagName("img"),imageArray=new Array;Array.prototype.forEach.call(imageList,(e=>{"no-view"!=e.alt&&"no-view"!=e.className&&imageArray.push(e)})),Array.prototype.forEach.call(imageArray,(e=>{var a=new Viewer(e);a.images=imageArray,a.length=imageArray.length}))</script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.4.0/dist/lazyload.min.js"></script><script>new LazyLoad({elements_selector:".post-content img"})</script></body></html>